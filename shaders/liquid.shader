#shader vertex#version 430 coreconst mat4 FACE_MATRICES[6] = mat4[6](    // Front face (X+)    mat4(        1.0,  0.0,  0.0,  0.0,        0.0,  1.0,  0.0,  0.0,        0.0,  0.0,  1.0,  0.0,        0.0,  0.0,  0.0,  1.0    ),    // Right face (Z+)    mat4(        0.0,  0.0,  1.0,  0.0,        0.0,  1.0,  0.0,  0.0,       -1.0,  0.0,  0.0,  0.0,        0.0,  0.0,  0.0,  1.0    ),    // Top face (Y+)    mat4(        0.0,  1.0,  0.0,  0.0,       -1.0,  0.0,  0.0,  0.0,        0.0,  0.0,  1.0,  0.0,        0.0,  0.0,  0.0,  1.0    ),        // Back face (X-)    mat4(       -1.0,  0.0,  0.0,  0.0,        0.0,  1.0,  0.0,  0.0,        0.0,  0.0, -1.0,  0.0,        0.0,  0.0,  0.0,  1.0    ),        // Left face (Z-)    mat4(        0.0,  0.0, -1.0,  0.0,        0.0,  1.0,  0.0,  0.0,        1.0,  0.0,  0.0,  0.0,        0.0,  0.0,  0.0,  1.0    ),        // Bottom face (Y-)    mat4(        0.0, -1.0,  0.0,  0.0,        1.0,  0.0,  0.0,  0.0,        0.0,  0.0,  1.0,  0.0,        0.0,  0.0,  0.0,  1.0    ));//globallayout(location = 0) in vec3 inPosition;//per instancelayout(location = 1) in vec3 inTranspos;layout(location = 2) in uint inAtlasIndex;layout(location = 3) in uint inFaceIndex;layout(location = 4) in uvec4 inLevels;struct EdgeLevels // hight of edges in pixels (from 0 to 16){	uint edgeXposZpos;	uint edgeXposZneg;	uint edgeXnegZpos;	uint edgeXnegZneg;};out vec2 UV;layout(std430, binding = 0) buffer textureData{    vec4 data[];};//uniform mat4 u_modelTransform;uniform mat4 u_viewTransform;uniform mat4 u_projectionTransform;void main(){    EdgeLevels levels;    levels.edgeXposZpos = inLevels.x;    levels.edgeXposZneg = inLevels.y;    levels.edgeXnegZpos = inLevels.z;    levels.edgeXnegZneg = inLevels.w;    vec2 uv = vec2(0.0);    uv = vec2(inPosition.z + 0.5, inPosition.y + 0.5);    vec4 rotatedPos = FACE_MATRICES[inFaceIndex] * vec4(inPosition, 1.0);    /*    if (rotatedPos.y > 0)    {        if (rotatedPos.x > 0 && rotatedPos.z > 0)            rotatedPos.y -= (16 - levels.edgeXposZpos) * 0.0625; // 0.0625 = 1/16 - one pixel size        else if (rotatedPos.x > 0 && rotatedPos.z < 0)            rotatedPos.y -= (16 - levels.edgeXposZneg) * 0.0625;        else if (rotatedPos.x < 0 && rotatedPos.z > 0)            rotatedPos.y -= (16 - levels.edgeXnegZpos) * 0.0625;        else if (rotatedPos.x < 0 && rotatedPos.z < 0)            rotatedPos.y -= (16 - levels.edgeXnegZneg) * 0.0625;    }    */    vec3 worldPos = rotatedPos.xyz + inTranspos;    gl_Position = u_projectionTransform * u_viewTransform * vec4(worldPos, 1.0);    // UV calculation with switch    // Apply atlas transformation    UV = data[inAtlasIndex].zw + uv * data[inAtlasIndex].xy;};#shader fragment#version 430 corelayout(location = 0) out vec4 outFragColor;in vec2 UV;uniform sampler2D u_Texture;// In fragment shadervec4 sampleAtlas(sampler2D atlas, vec2 uv) {    // Add small offset to avoid sampling outside texture boundaries    // In GLSL, you can get texel size using:    vec2 texelSize = 1.0 / textureSize(atlas, 0); // (1/width, 1/height)    vec2 safeUV = uv + texelSize * 0.5;    return texture(atlas, safeUV);}vec3 adjustContrastLuminance(vec3 color, float contrast) {    float luminance = dot(color, vec3(0.299, 0.587, 0.114));    vec3 luminanceColor = vec3(luminance);    return mix(luminanceColor, color, contrast);}void main(){    outFragColor = sampleAtlas(u_Texture, UV);    vec3 color = adjustContrastLuminance(outFragColor.xyz, 1.0);    outFragColor = vec4(color, outFragColor.w);};