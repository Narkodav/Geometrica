#shader vertex#version 430 core//const std::array<glm::ivec3, 7> constDirectionVectors3DHashed =//{//	glm::ivec3( 0,  0,  1),		// front / south//	glm::ivec3( 1,  0,  0),		// right / east//	glm::ivec3( 0,  1,  0),		// up //	glm::ivec3( 0,  0, -1),		// back / north//	glm::ivec3(-1,  0,  0),		// left / west//	glm::ivec3( 0, -1,  0),		// down//	glm::ivec3( 0,  0,  0),		// none (for utility)//};//enum class Directions3DHashed : unsigned int//{//	DIRECTION_FORWARD = 0,//	DIRECTION_RIGHT,//	DIRECTION_UP,//	DIRECTION_BACKWARD,//	DIRECTION_LEFT,//	DIRECTION_DOWN,//};layout(location = 0) in vec3 v_position;layout(location = 1) in vec2 v_texCoordIn;layout(location = 2) in vec2 v_normal;//per instancelayout(location = 3) in vec3 v_transpos;//layout(location = 4) in uint ui_FaceDirection;layout(location = 4) in uint ui_TextureIndex;out vec2 v_texCoord;layout(std430, binding = 0) buffer textureData{    vec4 data[];};//uniform mat4 u_modelTransform;uniform mat4 u_viewTransform;uniform mat4 u_projectionTransform;void main(){//    mat3 rotation;//    rotation = mat3(1.0);//    switch(ui_FaceDirection) {//        case 0: // Front face//            rotation = rotation = mat3(1.0);//            break;//        case 1: // Back face//            rotation = mat3( -1.0, 0.0, 0.0,//                             0.0, 1.0, 0.0,//                             0.0, 0.0, -1.0);//            break;//        case 2: // Right face//            rotation = mat3(0.0, 0.0, -1.0,//                            0.0, 1.0, 0.0,//                            1.0, 0.0, 0.0);//            break;//        case 3: // Left face//            rotation = mat3(0.0, 0.0, 1.0,//                            0.0, 1.0, 0.0,//                            -1.0, 0.0, 0.0);//            break;//        case 4: // Top face//            rotation = mat3(0.0, 1.0, 0.0,//                            -1.0, 0.0, 0.0,//                            0.0, 0.0, 1.0);//            break;//        case 5: // Bottom face//            rotation = mat3(0.0, -1.0, 0.0,//                            1.0, 0.0, 0.0,//                            0.0, 0.0, 1.0);//            break;//        default: // not a cube            gl_Position = u_projectionTransform * u_viewTransform * vec4(v_transpos + v_position, 1);            v_texCoord = vec2(data[ui_TextureIndex].z + v_texCoordIn.x * data[ui_TextureIndex].x, data[ui_TextureIndex].w + v_texCoordIn.y * data[ui_TextureIndex].y);//            return;//    }//   gl_Position = u_projectionTransform * u_viewTransform * vec4(v_transpos + rotation * v_position, 1);//   v_texCoord = vec2(data[ui_TextureIndex].z + v_texCoordIn.x * data[ui_TextureIndex].x, data[ui_TextureIndex].w + v_texCoordIn.y * data[ui_TextureIndex].y);};#shader fragment#version 430 corelayout(location = 0) out vec4 FragColor;in vec2 v_texCoord;uniform sampler2D u_Texture;vec3 adjustContrastLuminance(vec3 color, float contrast) {    float luminance = dot(color, vec3(0.299, 0.587, 0.114));    vec3 luminanceColor = vec3(luminance);    return mix(luminanceColor, color, contrast);}void main(){    FragColor = texture(u_Texture, v_texCoord);    vec3 color = adjustContrastLuminance(FragColor.xyz, 0.8);    FragColor = vec4(color, FragColor.w);	};